webpackJsonp([0],{2109:function(n,t,e){function i(n){return e(r(n))}function r(n){var t=s[n];if(!(t+1))throw new Error("Cannot find module '"+n+"'.");return t}var s={"./1":2115,"./1.js":2115,"./144":2116,"./144.js":2116,"./2":2117,"./2.js":2117,"./3":2118,"./3.js":2118,"./4":2119,"./4.js":2119,"./5":2120,"./5.js":2120,"./6":2121,"./6.js":2121,"./83":2122,"./83.js":2122,"./93":2123,"./93.js":2123,"./98":2124,"./98.js":2124,"./Euler":2125,"./Euler.js":2125,"./util/exectimer":2126,"./util/exectimer.js":2126,"./util/index":2127,"./util/index.js":2127,"./util/ispalindrome":2128,"./util/ispalindrome.js":2128,"./util/quadratic":2129,"./util/quadratic.js":2129,"./util/sieve_of_atkin":2130,"./util/sieve_of_atkin.js":2130};i.keys=function(){return Object.keys(s)},i.resolve=r,n.exports=i,i.id=2109},2110:function(n,t,e){function i(n){return e(r(n))}function r(n){var t=s[n];if(!(t+1))throw new Error("Cannot find module '"+n+"'.");return t}var s={"./1":1137,"./1.js":1137,"./144":1138,"./144.js":1138,"./2":1139,"./2.js":1139,"./3":1140,"./3.js":1140,"./4":1141,"./4.js":1141,"./5":1142,"./5.js":1142,"./6":1143,"./6.js":1143,"./83":1144,"./83.js":1144,"./93":1145,"./93.js":1145,"./98":1146,"./98.js":1146,"./Euler":75,"./Euler.js":75,"./util/exectimer":66,"./util/exectimer.js":66,"./util/index":1147,"./util/index.js":1147,"./util/ispalindrome":1148,"./util/ispalindrome.js":1148,"./util/quadratic":811,"./util/quadratic.js":811,"./util/sieve_of_atkin":1149,"./util/sieve_of_atkin.js":1149};i.keys=function(){return Object.keys(s)},i.resolve=r,n.exports=i,i.id=2110},2115:function(n,t){n.exports="import Euler from './Euler';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\n\nexport default class Euler1 extends Euler {\n    n = 1;\n    total = 0;\n\n    constructor() {\n        super();\n    }\n\n    *step() {\n        for(; this.n < 1000; this.n++) {\n            let tick = new Tick('step');\n            tick.start();\n\n            if(this.n % 3 === 0 || this.n % 5 === 0) this.total += this.n;\n\n            tick.stop();\n            yield this.total;\n        }\n        return this.total;\n    }\n}\n"},2116:function(n,t){n.exports="'use strict';\nimport Euler from './Euler';\nimport quadratic from './util/quadratic';\n// import { decorate } from 'core-decorators';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\n\nclass Point {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nexport default class Euler144 extends Euler {\n    p1;\n    p2;\n    x1;\n    y1;\n    x2;\n    y2;\n    ans;\n\n    constructor() {\n        super();\n        this.p1 = new Point(0.0, 10.1);\n        this.p1 = new Point(1.4, -9.6);\n        this.x1 = 0.0;\n        this.y1 = 10.1;\n        this.x2 = 1.4;\n        this.y2 = -9.6;\n        this.ans = 1;\n    }\n\n    /**\n     * This is currently not supported by Babylon:\n     *  @decorate(Tick.wrap)\n     *  *step() {}\n     */\n    *step() {\n        while(true) {\n            let tick = new Tick('step');\n            tick.start();\n            let m0 = (this.y2 - this.y1) / (this.x2 - this.x1);\n            let m1 = Euler144.deriv(this.x2, this.y2);\n            let tempX = this.x2;\n            let tempY = this.y2;\n            let X = (m0 - m1) / (1 + m0 * m1);\n            let m2 = (m1 - X) / (1 + X * m1);\n\n            let b = this.y2 - m2 * this.x2;\n            this.x2 = quadratic(m2, b, this.x2);\n            this.y2 = m2 * this.x2 + b;\n            this.verbose(`Hit ${this.x2}, ${this.y2}`);\n            this.x1 = tempX;\n            this.y1 = tempY;\n\n            // new point is inside hole\n            if(this.y2 > 0 && this.x2 > -.01 && this.x2 < .01) {\n                tick.stop();\n                return {\n                    x1: this.x1,\n                    y1: this.y1,\n                    x2: this.x2,\n                    y2: this.y2,\n                    ans: this.ans\n                };\n            } else {\n                this.ans++;\n                tick.stop();\n                yield {\n                    x1: this.x1,\n                    y1: this.y1,\n                    x2: this.x2,\n                    y2: this.y2,\n                    ans: this.ans\n                };\n            }\n        }\n    }\n\n    run() {\n        this.start();\n\n        const stepper = this.step();\n\n        let step;\n        do {\n            step = stepper.next();\n            this.verbose(`step: ${step.value}`);\n        } while(!step.done);\n\n        this.end();\n\n        let stepTimer = t.timers.step;\n\n        this.info(`Took ${stepTimer.count()} steps`);\n        this.info(`Took ${stepTimer.parse(stepTimer.duration())}`);\n        this.info(`Solution: ${this.ans}`);\n\n        return this.ans;\n    }\n\n    static deriv(x, y) {\n        return -4 * x / y;\n    }\n}\n"},2117:function(n,t){n.exports="'use strict';\nimport Euler from './Euler';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\n\nexport default class Euler2 extends Euler {\n    num1 = 1;\n    num2 = 1;\n    num3;\n    sum = 0;\n    max = 4000000;\n\n    constructor() {\n        super();\n    }\n\n    *step() {\n        while(this.num2 < this.max) {\n            let tick = new Tick('step');\n            tick.start();\n            if(this.num2 % 2 == 0) {\n                this.sum += this.num2;\n            }\n            this.num3 = this.num2;\n            this.num2 = this.num1 + this.num2;\n            this.num1 = this.num3;\n            tick.stop();\n            yield this.num2;\n        }\n        return this.sum;\n    }\n\n    run() {\n        this.start();\n\n        const stepper = this.step();\n\n        let step;\n        do {\n            step = stepper.next();\n            this.verbose(`step: ${step.value}`);\n        } while(!step.done);\n\n        this.end();\n\n        let stepTimer = t.timers.step;\n\n        this.info(`Took ${stepTimer.count()} steps`);\n        this.info(`Took ${stepTimer.parse(stepTimer.duration())}`);\n        console.log(`The Sum of all even Fibonacci numbers below ${this.max} is ${this.sum}`);\n\n        return this.sum;\n    }\n}\n"},2118:function(n,t){n.exports="'use strict';\nimport Euler from './Euler';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\n\nexport function isPrime(n) {\n    let i = 2;\n    let sqrtN = Math.sqrt(n).toFixed(0);\n\n    while(i <= sqrtN) {\n        if(n % i === 0) {\n            return false;\n        } else {\n            i++;\n        }\n    }\n\n    return true;\n}\n\nexport default class Euler3 extends Euler {\n    num = 600851475143;\n    factors = [];\n\n    constructor() {\n        super();\n    }\n\n    *step() {\n        let n = this.num;\n        let i = 2;\n\n        while(!isPrime(n) && n > 2) {\n            let tick = new Tick('step');\n            tick.start();\n\n            if(n % i === 0) {\n                yield i;\n                this.factors.push(i);\n                n = n / i;\n                i = 2;\n            }\n            i++;\n\n            tick.stop();\n        }\n\n        this.factors.push(n);\n\n        if(this.factors.reduce((acc, x) => acc * x, 1) !== this.num) throw new Error('Something went terribly wrong!');\n\n        this.solution = n;\n        return this.solution;\n    }\n}\n"},2119:function(n,t){n.exports="import Euler from './Euler';\nimport { Tick } from './util/exectimer';\nimport { isPalindrome } from './util';\n\nexport default class Euler4 extends Euler {\n    i;\n\n    *step() {\n        for(let x = 999; x >= 900; x--) {\n            for(let y = 999; y >= 900; y--) {\n                let tick = new Tick('step');\n                tick.start();\n\n                this.i = x * y;\n\n                let is = isPalindrome(String(this.i));\n\n                tick.stop();\n\n                if(is) {\n                    this.solution = this.i;\n                    return this.i;\n                } else {\n                    yield this.i;\n                }\n            }\n        }\n\n        return this.solution;\n    }\n}\n"},2120:function(n,t){n.exports="import Euler from './Euler';\nimport { Tick } from './util/exectimer';\n\nexport default class Euler5 extends Euler {\n    *step() {\n        let tick = new Tick('step');\n        tick.start();\n\n        this.solution = 2 * 3 * 4 * 5 * 6 * 7 * 11 * 13 * 17 * 19;\n\n        tick.stop();\n\n        return this.solution;\n    }\n}\n"},2121:function(n,t){n.exports="import Euler from './Euler';\nimport { Tick } from './util/exectimer';\n\nexport default class Euler6 extends Euler {\n    *step() {\n        let n1 = 1;\n        let n2 = 1;\n        let sum1 = 0;\n        let sum2 = 0;\n        let sum3;\n\n        while(n1 <= 100) {\n            let tick = new Tick('step');\n            tick.start();\n\n            sum1 += n1 ** 2;\n            n1++;\n\n            tick.stop();\n\n            yield sum1;\n        }\n        while(n2 <= 100) {\n            let tick = new Tick('step');\n            tick.start();\n\n            sum2 += n2;\n            n2++;\n\n            tick.stop();\n\n            yield sum2;\n        }\n        sum2 = (sum2 * sum2);\n        sum3 = sum2 - sum1;\n\n        this.solution = sum3;\n\n        return this.solution;\n    }\n}\n"},2122:function(n,t){n.exports="'use strict';\nimport _ from 'lodash-es';\nimport Euler from './Euler';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\n\nconst solutionMap5x5 = [\n[ 1 , 0 , 1 , 1 , 1 ],\n[ 1 , 1 , 1 , 0 , 1 ],\n[ 0 , 0 , 0 , 1 , 1 ],\n[ 0 , 0 , 0 , 1 , 0 ],\n[ 0 , 0 , 0 , 1 , 1 ]];\nconst solution5x5 = 2297;\n// const solution = require('../data/solutions.json')['83'];\n// console.log(solution5x5);\n// console.log(solution);  // 425185\n/**\n * G = cost from A to square\n * H = extimated cost from square to B\n * F = score, G + H\n */\n\nlet up = ([row, col]) => [row - 1, col];\nlet down = ([row, col]) => [row + 1, col];\nlet left = ([row, col]) => [row, col - 1];\nlet right = ([row, col]) => [row, col + 1];\n\nexport default class Euler83 extends Euler {\n    position = [0, 0];\n    min = 18;\n    rows = 5;\n    cols = 5;\n    endPosition = [4, 4];\n    moves = 0;\n    open = [];\n    closed = [];\n    weightMap;\n    // map;\n    solution = 0;\n\n    static parseMatrix(matrix) {\n        return matrix\n            .toString()\n            .trim()\n            .split('\\n')\n            .map(line => {\n                return line\n                    .split(',')\n                    .map(c => parseInt(c));\n            });\n    }\n\n    constructor(matrix) {\n        super();\n\n        this.weightMap = matrix;\n        this.rows = matrix.length;\n        this.cols = matrix[0].length;\n\n        this.heuristicMap = [];\n        for(let i = 0; i < this.rows; i++) {\n            let row = [];\n            for(let j = 0; j < this.cols; j++) {\n                row.push(this.min * ((5 -  i) + (5 - j) - 1));\n            }\n            this.heuristicMap.push(row);\n        }\n\n        this.solution += this.weightMap[0][0];    // add starting position weight\n\n        // add first points to open\n        let p1 = {\n            position: [0, 1],\n            g: this.weightMap[0][1],\n            h: this.heuristicMap[0][1]\n        };\n        p1.f = p1.g + p1.h;\n\n        let p2 = {\n            position: [1, 0],\n            g: this.weightMap[1][0],\n            h: this.heuristicMap[1][0],\n        };\n        p2.f = p2.g + p2.h;\n\n        if(p1.f <= p2.f) {\n            this.open.push(p1, p2);\n        } else {\n            this.open.push(p2, p1);\n        }\n\n        // add starting point to closed list\n        let start = {\n            position: [0, 0],\n            g: this.weightMap[0][0],\n            h: this.heuristicMap[0][0],\n        };\n        start.f = start.g + start.h;\n        this.closed.push(start);\n    }\n\n    *step() {\n        while(this.position !== this.endPosition) {\n            let tick = new Tick('step');\n            tick.start();\n\n            let next = this.open.splice(0, 1)[0];\n            this.info(`Next: ${next.position}`);\n            this.solution += next.g;\n            this.closed.push(next);\n\n            if(next.position[0] === this.endPosition[0] && next.position[1] === this.endPosition[1]) {\n                // done\n                tick.stop();\n\n                this.info('Reached end!');\n\n                return this.solution;\n            }\n\n            // add new points, if possible (in sorted position)\n            this.addToOpen(up(next.position));\n            this.addToOpen(down(next.position));\n            this.addToOpen(left(next.position));\n            this.addToOpen(right(next.position));\n\n            yield next;\n            tick.stop();\n        }\n    }\n\n    addToOpen([row, col]) {\n        if(!this.canGo([row, col])) return false;\n        if(this.open.map(point => point.position).indexOf([row, col]) > -1) return false;\n\n        let point = {\n            position: [row, col],\n            g: this.weightMap[row][col],\n            h: this.heuristicMap[row][col]\n        };\n        point.f = point.g + point.h;\n\n        let index = _.sortedIndexBy(this.open, point, 'f');\n        this.open.splice(index, 0, point);\n    }\n\n    canGo([row, col]) {\n        // out of bounds check\n        if(row < 0 || col < 0 || row >= this.rows || col >= this.cols) {\n            return false;\n        }\n\n        // check if in closed list\n        let closedLength = this.closed.length;\n        for(let i = 0; i < closedLength; i++) {\n            if(this.closed[i].position[0] === row && this.closed[i].position[1] === col) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"},2123:function(n,t){n.exports="'use strict';\nimport _ from 'lodash-es';\nimport Euler from './Euler';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\nimport math from 'mathjs';\n\n/**\n * @returns {Boolean}\n */\nfunction repeats(a, b, c, d) {\n    return _.uniq([a, b, c, d]).length !== 4;\n}\n\nfunction permute(array, returnMap = false) {\n    var p = -1;\n    var j;\n    var k;\n    var f;\n    var r;\n    var l = array.length;\n    // number of permutations\n    var q = math.factorial(l);\n    var i = l + 1;\n\n    var x = [new Array(l), new Array(l), new Array(l), new Array(l)];\n\n    for(j = q, k = l + 1, i = -1; ++i < l; x[2][i] = i, x[1][i] = x[0][i] = j /= --k);\n\n    for(r = new Array(q); ++p < q;) {\n        for(r[p] = new Array(l), i = -1; ++i < l; !--x[1][i] && (x[1][i] = x[0][i],\n            x[2][i] = (x[2][i] + 1) % l), r[p][i] = returnMap ? x[3][i] : array[x[3][i]]) {\n            for(x[3][i] = x[2][i], f = 0; !f; f = !f) {\n                for(j = i; j; x[3][--j] == x[2][i] && (x[3][i] = x[2][i] = (x[2][i] + 1) % l, f = 1));\n            }\n        }\n    }\n\n    return r;\n}\n\nconst operators = ['+', '-', '*', '/'];\n\nexport default class Euler83 extends Euler {\n    methods = [{\n        key: 'bruteForce1',\n        name: 'Brute Force 1',\n        description: 'My first brute force attempt'\n    }];\n    solution = {\n        numConsecutive: 28,\n        a: 1,\n        b: 2,\n        c: 3,\n        d: 4\n    };\n\n    constructor() {\n        super();\n\n        this.method = this[this.methods[0].key];\n    }\n\n    // brute force, get's the job done, but takes about 300s\n    *bruteForce1() {\n        for(let a = 1; a <= 6; a++) {\n            for(let b = 2; b <= 7; b++) {\n                for(let c = 3; c <= 8; c++) {\n                    for(let d = 4; d <= 9; d++) {\n                        // if(any digits repeat) continue\n                        if(repeats(a, b, c, d)) continue;\n                        // each sequence\n                        let tick = new Tick('step');\n                        tick.start();\n\n                        let numPermutations = permute([a, b, c, d]);\n                        let targets = [];\n\n                        _.forEach(numPermutations, np => {\n                            _.forEach(operators, op1 => {\n                                _.forEach(operators, op2 => {\n                                    _.forEach(operators, op3 => {\n                                        targets.push(math.eval(`${np[0]} ${op1} ${np[1]} ${op2} ${np[2]} ${op3} ${np[3]}`));\n                                        targets.push(math.eval(`(${np[0]} ${op1} ${np[1]}) ${op2} (${np[2]} ${op3} ${np[3]})`));\n                                        targets.push(math.eval(`${np[0]} ${op1} (${np[1]} ${op2} ${np[2]} ${op3} ${np[3]})`));\n                                        targets.push(math.eval(`${np[0]} ${op1} (${np[1]} ${op2} ${np[2]}) ${op3} ${np[3]}`));\n                                        targets.push(math.eval(`${np[0]} ${op1} ${np[1]} ${op2} (${np[2]} ${op3} ${np[3]})`));\n                                    });\n                                });\n                            });\n                        });\n\n                        // filter & sort\n                        targets = _.chain(targets)\n                            .filter(target => math.isInteger(target) && target > 0)\n                            .uniq()\n                            .thru(targets => targets.sort((a, b) => a - b))\n                            .value();\n\n                        let numConsecutive = 1;\n\n                        for(let i = 0; i < targets.length; i++) {\n                            if(targets[i] + 1 === targets[i + 1]) {\n                                numConsecutive++;\n                            } else {\n                                break;\n                            }\n                        }\n\n                        if(numConsecutive > this.solution.numConsecutive) {\n                            this.solution = {numConsecutive, a, b, c, d}\n                        }\n\n                        this.info(`[${a}, ${b}, ${c}, ${d}]: ${numConsecutive}`);\n\n                        yield numConsecutive;\n\n                        tick.stop();\n                    }\n                }\n            }\n        }\n\n        this.info(`Solution: [${a}, ${b}, ${c}, ${d}]: ${numConsecutive}`);\n\n        return this.solution;\n    }\n\n    *step() {\n        yield* this.method();\n    }\n}\n"},2124:function(n,t){n.exports="'use strict';\n// import fs from 'fs';\n// import path from 'path';\nimport _ from 'lodash-es';\nimport Euler from './Euler';\nimport t from './util/exectimer';\nconst Tick = t.Tick;\nimport math from 'mathjs';\n// import {permute} from './util/array';\n\n// CARE = 1296 = 36^2\n// RACE = 9216 = 96^2\n\nfunction groupPairs(items) {\n    let pairs = [];\n\n    _.forEach(items, (item1, i) => {\n        _.forEach(items, (item2, j) => {\n            if(j <= i) return;\n\n            pairs.push([item1, item2]);\n        });\n    });\n\n    return pairs;\n}\n\nfunction getSquarePairs(upToLength) {\n    let i = 1;\n    let limit = math.pow(10, upToLength);\n    let pairs = {};\n\n    while(true) {\n        let square = i * i;\n        if(square > limit) break;\n\n        let hash = `${square}`.split('').sort().join('');\n\n        if(!pairs[hash]) pairs[hash] = [];\n        pairs[hash].push(square);\n\n        i++;\n    }\n\n    let take2 = array => _.partialRight(_.take, 2)(array);\n    return _.chain(pairs)\n        .filter(group => group.length > 1)\n        .flatMap(group => {\n            if(group.length === 2) return [group];\n\n            return groupPairs(group);\n        })\n        .value();\n}\n\n/**\n * @param {String} word\n * @param {String} number\n */\nfunction getLetterMapping(word, number) {\n    word = word.split('');\n    number = number.split('');\n    let mapping = {};\n\n    for(let i = 0; i < word.length; i++) {\n        // make sure that letters are only assigned a single value\n        let previousMapping = mapping[word[i]];\n        if(previousMapping && previousMapping !== number[i]) {\n            return false;\n        }\n\n        mapping[word[i]] = number[i];\n    }\n\n    // make sure two different letters aren't assigned the same value\n    let accumulator = {};\n    for(let key of Object.keys(mapping)) {\n        if(accumulator[mapping[key]]) return false;\n\n        accumulator[mapping[key]] = true;\n    }\n\n    return mapping;\n}\n\nfunction mapWord(word, mapping) {\n    let number = [];\n    _.forEach(word.split(''), letter => {\n        number.push(mapping[letter]);\n    });\n    return parseInt(number.join(''));\n}\n\nexport default class Euler98 extends Euler {\n    solution = 0;\n\n    constructor() {\n        super();\n\n        this.words = Euler98.parseWords(fs.readFileSync(path.join(__dirname, '..', 'data/words98.txt'), 'utf8'));\n    }\n\n    static parseWords(str) {\n        return str.split(',').map(word => word.replace(/\"/g, ''));\n    }\n\n    *step() {\n        const self = this;\n        // get groups of anagramic pairs\n        let wordPairs = _.chain(this.words)\n            // group by words converted to strings of their sorted letters ('SHOE' => 'EHOS')\n            .groupBy(word => word.split('').sort().join(''))\n            // filter out any groups of only one word (no pairs)\n            .filter(group => group.length > 1)\n            // split groups of 3+ into all possible pairs\n            .flatMap(group => {\n                if(group.length === 2) return [group];\n\n                return groupPairs(group);\n            })\n            .value();\n\n        this.verbose(wordPairs);\n\n        yield wordPairs;\n\n        let maxLength = 0;\n\n        // get the lengths of words we have\n        _.forEach(wordPairs, group => {\n            let length = group[0].length;\n            if(length > maxLength) maxLength = length;\n        });\n\n        let squarePairs = _.groupBy(getSquarePairs(maxLength), pair => `${pair[0]}`.length);\n\n        this.verbose(squarePairs);\n\n        yield squarePairs;\n\n        _.forEach(wordPairs, wordPair => {\n            let length = wordPair[0].length;\n            _.forEach(squarePairs[length], squarePair => {\n                let tick = new Tick('step');\n                tick.start();\n\n                let mapping0 = getLetterMapping(wordPair[0], `${squarePair[0]}`);\n                if(mapping0 === false) return;\n\n                let mappedNum = mapWord(wordPair[1], mapping0);\n\n                if(squarePair[1] === mappedNum) {\n                    self.info(`Pair found: ${wordPair[0]} -> ${squarePair[0]}, ${wordPair[1]} -> ${squarePair[1]}`);\n                    if(squarePair[0] > this.solution) this.solution = squarePair[0];\n                    if(squarePair[1] > this.solution) this.solution = squarePair[1];\n                }\n\n                tick.stop();\n\n                // yield {wordPair, squarePair};\n            });\n        });\n\n        return this.solution;\n    }\n\n    run() {\n        this.start();\n\n        const stepper = this.step();\n\n        let step;\n        do {\n            let tick = new Tick('step');\n            tick.start();\n            step = stepper.next();\n            tick.stop();\n            this.verbose(`step: ${step.value}`);\n        } while(!step.done);\n\n        this.end();\n\n        let stepTimer = t.timers.step;\n\n        this.info(`Took ${stepTimer.count()} steps`);\n        this.info(`Took ${stepTimer.parse(stepTimer.duration())}`);\n        this.info(`Soluion: ${this.solution}`);\n\n        return this.sum;\n    }\n}\n"},2125:function(n,t){n.exports="// import microtime from 'microtime';\nimport * as marky from 'marky/lib/marky.browser.es';\n// import moment from 'moment';\nimport t from './util/exectimer';\n// const Tick = t.Tick;\n\n// { error: 0, warn: 1, info: 2, verbose: 3, debug: 4, silly: 5 }\nglobal.logLevel = global.logLevel || 'info';\n\nvar performance = global.performance || {};\nvar performanceNow =\n    performance.now        ||\n    performance.mozNow     ||\n    performance.msNow      ||\n    performance.oNow       ||\n    performance.webkitNow  ||\n    function(){ return (new Date()).getTime() };\n\nwindow.process = global.process = {\n    hrtime(previousTimestamp) {\n        var clocktime = performanceNow.call(performance)*1e-3;\n        var seconds = Math.floor(clocktime);\n        var nanoseconds = Math.floor((clocktime%1)*1e9);\n\n        if (previousTimestamp) {\n            seconds = seconds - previousTimestamp[0];\n            nanoseconds = nanoseconds - previousTimestamp[1];\n            if (nanoseconds<0) {\n                seconds--;\n                nanoseconds += 1e9;\n            }\n        }\n\n        return [seconds,nanoseconds]\n    }\n};\n// TODO: write own polymorphic exectimer\n\nexport default class Euler {\n    solution;\n\n    constructor() {\n        this.duration = null;\n        this.key = `${Math.random()}`;\n\n        // const name = this.constructor.name;\n\n        // let isNode;\n        // try {\n        //     isNode = !!process.release;\n        // } catch(e) {\n        //     isNode = false;\n        // }\n        //\n        // console.log('isNode', isNode);\n        //\n        // if(isNode) {\n        //     try {\n        //         const chalk = require('chalk');\n        //         const winston = require('winston');\n        //         const Logger = winston.Logger;\n        //         const Console = winston.transports.Console;\n        //\n        //         this.logger = new Logger({\n        //             transports: [\n        //                 new Console({\n        //                     level: global.logLevel,\n        //                     /**\n        //                      * @returns {String}\n        //                      */\n        //                     timestamp() {\n        //                         return moment(Date.now()).format('MM.DD.YY H:mm:ss');\n        //                     },\n        //                     /**\n        //                      * @param {Object} opts\n        //                      * @param {Function} opts.timestamp\n        //                      * @param {String} opts.level\n        //                      * @param {String} [opts.message]\n        //                      * @param {*} [opts.meta]\n        //                      */\n        //                     formatter(opts) {\n        //                         // Return string will be passed to logger.\n        //                         const time = chalk.blue(opts.timestamp());\n        //                         const level = opts.level.toUpperCase();\n        //                         const coloredLevel =\n        //                             level === 'WARN' ? chalk.yellow('WARN') :\n        //                                 level === 'ERROR' ? chalk.red('ERROR') :\n        //                                     level;\n        //                         const message = opts.message !== undefined ? opts.message : '';\n        //                         const meta = opts.meta && Object.keys(opts.meta).length ? `\\n\\t${JSON.stringify(opts.meta)}` : '';\n        //                         return `[${chalk.green(name)}][${time}][${coloredLevel}] ${message}${meta}`;\n        //                     }\n        //                 })\n        //             ]\n        //         });\n        //     } catch(e) {\n        //         this.logger = console;\n        //         this.logger.verbose = console.log;\n        //     }\n        // } else {\n            this.logger = console;\n            this.logger.verbose = console.log;\n        // }\n    }\n\n    start() {\n        marky.mark(this.key);\n        // this.startTime = microtime.now();\n    }\n\n    *step() {\n        throw new Error('You need to override this, doofus');\n    }\n\n    end() {\n        // this.endTime = microtime.now();\n        // this.duration = this.endTime - this.startTime;\n        this.duration = marky.stop(this.key).duration;\n    }\n\n    run() {\n        const stepper = this.step();\n\n        this.start();\n\n        let step;\n        do {\n            step = stepper.next();\n            this.verbose(`step: ${step.value}`);\n        } while(!step.done);\n\n        this.end();\n\n        let stepTimer = t.timers.step;\n\n        this.info(`Solution: ${step.value}`);\n        this.info(`Took ${stepTimer.count()} steps`);\n        this.info(`Took ${parseInt(this.duration)}ms`);\n\n        return {\n            solution: step.value,\n            duration: this.duration,\n        };\n    }\n\n    error(...args) {\n        this.logger.error(...args);\n    }\n    warn(...args) {\n        this.logger.warn(...args);\n    }\n    info(...args) {\n        this.logger.info(...args);\n    }\n    verbose(...args) {\n        this.logger.verbose(...args);\n    }\n    debug(...args) {\n        this.logger.debug(...args);\n    }\n    silly(...args) {\n        this.logger.silly(...args);\n    }\n    log(...args) {\n        this.logger.log(...args);\n    }\n}\n"},2126:function(n,t){n.exports="'use strict';\nimport co from 'co';\n\n/**\n * Contains all timers.\n * @type {{}}\n */\nexport const timers = {};\n\nclass Timer {\n  ticks = [];\n\n  /**\n   * Get the median of all ticks.\n   * @returns {*}\n   */\n  median() {\n    if(this.ticks.length > 1) {\n      const sorted = this.ticks.slice(0).sort((a, b) => {\n        return a && b && (a.getDiff() - b.getDiff()) || 0;\n      });\n\n      const length = sorted.length;\n      const half = Math.floor(length / 2);\n\n      if(length % 2) {\n        return sorted[half].getDiff();\n      } else {\n        return (sorted[half - 1].getDiff() + sorted[half].getDiff()) / 2;\n      }\n    } else {\n      return this.ticks[0].getDiff();\n    }\n  }\n\n  /**\n   * Get the average duration of all ticks.\n   * @returns {number}\n   */\n  mean() {\n    return this.duration() / this.ticks.length;\n  }\n\n  /**\n   * Get the duration of all ticks.\n   * @returns {number}\n   */\n  duration() {\n    let sum = 0;\n    let length = this.ticks.length;\n    for(let i = 0; i < length; i++) {\n      sum += this.ticks[i].getDiff();\n    }\n    return sum;\n  }\n\n  /**\n   * Get the shortest tick.\n   * @returns {number}\n   */\n  min() {\n    let min = this.ticks[0].getDiff();\n\n    this.ticks.forEach(tick => {\n      if(tick.getDiff() < min) {\n        min = tick.getDiff();\n      }\n    });\n\n    return min;\n  }\n\n  /**\n   * Get the longest tick.\n   * @returns {number}\n   */\n  max() {\n    let max = 0;\n\n    this.ticks.forEach(tick => {\n      if(tick.getDiff() > max) {\n        max = tick.getDiff();\n      }\n    });\n\n    return max;\n  }\n\n  /**\n   * Get the number of ticks.\n   * @returns {Number}\n   */\n  count() {\n    return Object.keys(this.ticks).length;\n  }\n\n  /**\n   * Parse the numbers nicely.\n   * @param num\n   * @returns {string}\n   */\n  parse(num) {\n    if(num < 1e3) {\n      return num + 'ns';\n    } else if(num >= 1e3 && num < 1e6) {\n      return num / 1e3 + 'us';\n    } else if(num >= 1e6 && num < 1e9) {\n      return num / 1e6 + 'ms';\n    } else if(num >= 1e9) {\n      return num / 1e9 + 's';\n    }\n  }\n}\n\n/**\n * Timers factory object.\n * @param name\n * @returns {*}\n */\nexport const timer = function(name) {\n  if(typeof timers[name] === 'undefined') {\n    timers[name] = new Timer();\n  }\n\n  return timers[name];\n};\n\nexport class Tick {\n  /**\n   * Constructor of tick.\n   * @param name The name of this tick.\n   * @returns {Tick}\n   * @constructor\n   */\n  constructor(name) {\n    this.name = name;\n    return this;\n  }\n\n  static wrap(name, callback) {\n    if(typeof name === 'function') {\n      callback = name;\n      name = functionName(callback);\n    }\n\n    if(name === '') {\n      name = 'anon';\n    }\n\n    const tick = new Tick(name);\n    tick.start();\n\n    const done = function() {\n      tick.stop();\n    };\n\n    if(isGeneratorFunction(callback)) {\n      return co(callback).then(done, done);\n    } else if(isFunction(callback)) {\n      // If done is passed when the callback is declared than we assume is async\n      return callback(done);\n    } else {\n      // Otherwise just call the function and stop the tick\n      tick.stop();\n      return callback();\n    }\n  }\n\n  /**\n   * Starts the tick.\n   */\n  start() {\n    this.hrstart = envTimer();\n    timer(this.name).ticks.push(this);\n  }\n\n  /**\n   * Ends the tick.\n   */\n  stop() {\n    this.hrend = envTimer(this.hrstart);\n  }\n\n  /**\n   * Get the duration of the tick.\n   * @returns Long nanoseconds\n   */\n  getDiff() {\n    return this.hrend[0] * 1e9 + this.hrend[1];\n  }\n}\n\nfunction envTimer(time) {\n  if(!process || !process.browser) {\n    if(time === null) {\n      return process.hrtime();\n    } else {\n      return process.hrtime(time);\n    }\n  } else {\n    if(time === null) {\n      return perf.now();\n    } else {\n      return perf.now() - time;\n    }\n  }\n}\n\nexport default {\n  timer,\n  timers,\n  Tick\n};\n\n/**\n * Helper function used to retrieve function name.\n * @param fun\n * @returns {string}\n */\nfunction functionName(fun) {\n  let ret = fun.toString();\n  ret = ret.substr('function '.length);\n  ret = ret.substr(0, ret.indexOf('('));\n  return ret.trim();\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} value\n * @return {Boolean}\n * @api private\n */\nfunction isGeneratorFunction(value) {\n  return typeof value === 'function' && value.constructor.name === 'GeneratorFunction';\n}\n\n/**\n * Helper function used to check is argument is of type function\n * @author https://github.com/lodash/lodash/blob/4.16.4/lodash.js#L11590\n * @param value\n * @returns {boolean}\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? Object.prototype.toString.call(value) : '';\n  return tag == '[object Function]' || tag == '[object GeneratorFunction]' || tag == '[object Proxy]';\n}\n\n/**\n * Helper function used to check is argument is of type object\n * @author https://github.com/lodash/lodash/blob/4.16.4/lodash.js#L11590\n * @param value\n * @returns {boolean}\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n"},2127:function(n,t){n.exports="export { default as quadratic } from './quadratic';\r\nexport { default as isPalindrome } from './ispalindrome';\r\nexport { default as sieveOfAtkin } from './sieve_of_atkin';\r\n"},2128:function(n,t){n.exports="/**\r\n * @author Awk34\r\n */\r\nexport default function isPalindrome(str) {\r\n    if(typeof str !== 'string') str = String(str);\r\n\r\n    const len = Math.floor(str.length / 2);\r\n\r\n    for(let i = 0; i < len; i++) {\r\n        if(str[i] !== str[str.length - i - 1])\r\n            return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n"},2129:function(n,t){n.exports="/**\n *\n * @param m2\n * @param n\n * @param x2\n * @returns {number}\n */\nexport default function quadratic(m2, n, x2) {\n    let a = 4 + m2 * m2;\n    let b = 2 * m2 * n;\n    let c = n * n - 100;\n\n    let ans1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    let ans2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    let dx1 = x2 - ans1;\n    let dx2 = x2 - ans2;\n    dx1 = dx1 > 0 ? dx1 : -dx1;\n    dx2 = dx2 > 0 ? dx2 : -dx2;\n\n    if(dx1 > dx2) return ans1;\n    else return ans2;\n}\n"},2130:function(n,t){n.exports="/**\n * @param {Number} limit=1000 - end of the sieve\n */\nexport default function SieveOfAtkin(limit = 1000) {\n    let sieve = new Array(limit + 1);\n    let limitSqrt = Math.sqrt(limit).toFixed(0);\n\n    // there may be more efficient data structure\n    // arrangements than this (there are!) but\n    // this is the algorithm in Wikipedia\n    // initialize results array\n    sieve.fill(false);\n    // the sieve works only forintegers > 3, so\n    // set these trivially to their proper values\n    sieve[0] = false;\n    sieve[1] = false;\n    sieve[2] = true;\n    sieve[3] = true;\n\n    // loop through all possible integer values forx and y\n    // up to the square root of the max prime forthe sieve\n    // we don't need any larger values forx or y since the\n    // max value forx or y will be the square root of n\n    // in the quadratics\n    // the theorem showed that the quadratics will produce all\n    // primes that also satisfy their wheel factorizations, so\n    // we can produce the value of n from the quadratic first\n    // and then filter n through the wheel quadratic\n    // there may be more efficient ways to do this, but this\n    // is the design in the Wikipedia article\n    // loop through all integers forx and y forcalculating\n    // the quadratics\n    for(let x = 1; x <= limitSqrt; x++) {\n        for(let y = 1; y <= limitSqrt; y++) {\n            // first quadratic using m = 12 and r in R1 = {r : 1, 5}\n            let n = (4 * x * x) + (y * y);\n            if(n <= limit && (n % 12 == 1 || n % 12 == 5)) {\n                sieve[n] = !sieve[n];\n            }\n            // second quadratic using m = 12 and r in R2 = {r : 7}\n            n = (3 * x * x) + (y * y);\n            if(n <= limit && (n % 12 == 7)) {\n                sieve[n] = !sieve[n];\n            }\n            // third quadratic using m = 12 and r in R3 = {r : 11}\n            n = (3 * x * x) - (y * y);\n            if(x > y && n <= limit && (n % 12 == 11)) {\n                sieve[n] = !sieve[n];\n            }\n            // note that R1 union R2 union R3 is the set R\n            // R = {r : 1, 5, 7, 11}\n            // which is all values 0 < r < 12 where r is\n            // a relative prime of 12\n            // Thus all primes become candidates\n        }\n    }\n    // remove all perfect squares since the quadratic\n    // wheel factorization filter removes only some of them\n    for(let n = 5; n <= limitSqrt; n++) {\n        if(sieve[n]) {\n            let x = n * n;\n            for(let i = x; i <= limit; i += x) {\n                sieve[i] = false;\n            }\n        }\n    }\n\n    return sieve;\n}\n"}});